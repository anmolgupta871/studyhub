<html>
<body>
<div align="justify">
<center> <h2>
BCA 6TH SEMESTER EXAMINATION</br>
Sample paper</br>
 SOFTWARE ENGINEERING</br><h2>
</center>

<font size= 5>

Time : 3 hours </br><div align="right"> Maximum Marks : 85</div>
Note :All  question  is compulsory.</br></h2>

                                       <center>  Section “A”  </br>      </center>                       <div align="right">     5 Marks in each ques</br></div></font>
<font size= 5>Que1:- Write about concept of software product.</br>

Ans.</font> Product development involves constantly adapting processes that can kgh a completed development process cycle.
 To avoid this inevitable occurrence the development approach of Concept Inc. is to use agile processes that can be in tune with quickly shifting requirements. We also create software products from the current demands of market trends and thus future proof the supposed functionality of the product based on the needs of a growing market opportunity. Through these processes and the strength of economies of scale cost savings can then be passed on to the end user and the new product can be supported as the customer requires it.
Description
Manufacturers have long employed analogous engineering techniques to create a product line of similar products using a common factory that assembles and configures parts designed to be reused across the product line. For example, automotive manufacturers can create unique variations of one car model using a single pool of carefully designed parts and a factory specifically designed to configure and assemble those parts.
The characteristic that distinguishes software product lines from previous efforts is predictive versus opportunistic software reuse. Rather than put general software components into a library in the hope that opportunities for reuse will arise, software product lines only call for software artifacts to be created when reuse is predicted in one or more products in a well defined product line.
Recent advances in the software product line field have demonstrated that narrow and strategic application of these concepts can yield order of magnitude improvements in software engineering capability. The result is often a discontinuous jump in competitive business advantage[citation needed], similar to that seen when manufacturers adopt mass production and mass customization paradigms.
Development
While early software product line methods at the genesis of the field provided the best software engineering improvement metrics seen in four decades, the latest generation of software product line methods and tools are exhibiting even greater improvements. New generation methods are extending benefits beyond product creation into maintenance and evolution, lowering the overall complexity of product line development, increasing the scalability of product line portfolios, and enabling organizationsto make the transition to software product line practice with orders of magnitude less time, cost and effort.</br>
<font size= 5>Que.2. What is the meaning of prototype in software engineering?</br>
Ans.</font>The prototyping model is applied when detailed information related to input and output requirements of the system is not available. In this model, it is assumed that all the requirements may not be known at the start of the development of the system. It is usually used when a system does not exist or in case of a large and complex system where there is no manual process to determine the requirements. This model allows the users to interact and experiment with a working model of the system known as prototype. The prototype gives the user an actual feel of the system.
At any stage, if the user is not satisfied with the prototype, it can be discarded and an entirely new system can be developed. Generally, prototype can be prepared by the approaches listed below. 
</br>• By creating main user interfaces without any substantial coding so that users can get a feel of how the actual system will appear.
</br>• By abbreviating a version of the system that will perform limited subsets of functions.</br>
 Using the prototype, the client can get an actual feel of the system. So, this case of model is beneficial in the case when requirements cannot be freezed initially. 
 This prototype is developed based on the currently known requirements. Development of the prototype obviously undergoes design, coding, and testing,  but each of these phases is not done very formally or thoroughly.  
By using this prototype, the client can get an actual feel of the system, because the interactions with the prototype can enable the client to better understand the requirements of the desired system.</br>
                                       
 <font size= 5>Que.3.Write about software project planning in software engineering.</br>
 Ans.</font>Before starting a software project, it is essential to determine the tasks to be performed and properly manage allocation of tasks among individuals involved in the software development. Hence, planning is important as it results in effective software development.
Project planning is an organized and integrated management process, which focuses on activities required for successful completion of the project. It prevents obstacles that arise in the project such as changes in projects or organization's objectives, non-availability of resources, and so on. Project planning also helps in better utilization of resources and optimal usage of the allotted time for a project. The other objectives of project planning are listed below.
</br>•	It defines the roles and responsibilities of the project management team members.
</br>•	It ensures that the project management team works according to the business objectives.
</br>•	It checks feasibility of the schedule and user requirements.
</br>•	It determines project constraints.
Several individuals help in planning the project. These include senior management and project management team. Senior management is responsible for employing team members and providing resources required for the project. The project management team, which generally includes project managers and developers, is responsible for planning, determining, and tracking the activities of the project. Table lists the tasks performed by individuals involved in the software project
Que4. Write about software design.</br> 
Ans.Software design is the process of implementing software solutions to one or more sets of problems. One of the main components of software design is the software requirements analysis (SRA). SRA is a part of the software development process that lists specifications used in software engineering. If the software is "semi-automated" or user centered, software design may involve user experience design yielding a storyboard to help determine those specifications. If the software is completely automated (meaning no user or user interface), a software design may be as simple as a flow chart or text describing a planned sequence of events. There are also semi-standard methods like Unified Modeling Language and Fundamental modeling concepts. In either case, some documentation of the plan is usually the product of the design. Furthermore, a software design may be platform-independent or platform-specific, depending upon the availability of the technology used for the design.
The main difference between software analysis and design is that the output of a software analysis consists of smaller problems to solve. Additionally, the analysis should not be designed very differently across different team members or groups. In contrast, the design focuses on capabilities, and thus multiple designs for the same problem can and will exist. Depending on the environment, the design often varies, whether it is created from reliable frameworks or implemented with suitable design patterns. Design examples include operation systems, webpages, mobile devices or even the new cloud computing paradigm.
Software design is both a process and a model. The design process is a sequence of steps that enables the designer to describe all aspects of the software for building. Creative skill, past experience, a sense of what makes "good" software, and an overall commitment to quality are examples of critical success factors for a competent design. It is important to note, however, that the design process is not always a straightforward procedure; the design model can be compared to an architect’s plans for a house. It begins by representing the totality of the thing that is to be built (e.g., a three-dimensional rendering of the house); slowly, the thing is refined to provide guidance for constructing each detail (e.g., the plumbing lay). Similarly, the design model that is created for software provides a variety of different views of the computer software. Basic design principles enable the software engineer to navigate the design process.suggests a set of principles for software design, which have been adapted and extended in the following list:</br>
</br>•	The design process should not suffer from "tunnel vision." A good designer should consider alternative approaches, judging each based on the requirements of the problem, the resources available to do the job.
</br>•	The design should be traceable to the analysis model. Because a single element of the design model can often be traced back to multiple requirements, it is necessary to have a means for tracking how requirements have been satisfied by the design model.
</br>•	The design should not reinvent the wheel. Systems are constructed using a set of design patterns, many of which have likely been encountered before. These patterns should always be chosen as an alternative to reinvention. Time is short and resources are limited; design time should be invested in representing (truly new) ideas by integrating patterns that already exist (when applicable).
</br>•	The design should "minimize the intellectual distance" between the software and the problem as it exists in the real world. That is, the structure of the software design should, whenever possible, mimic the structure of the problem domain.
</br>•	The design should exhibit uniformity and integration. A design is uniform if it appears fully coherent. In order to achieve this outcome, rules of style and format should be defined for a design team before design work begins. A design is integrated if care is taken in defining interfaces between design components.
</br>•	The design should be structured to accommodate change. The design concepts discussed in the next section enable a design to achieve this principle.
</br>•	The design should be structured to degrade gently, even when aberrant data, events, or operating conditions are encountered. Well- designed software should never "bomb"; it should be designed to accommodate unusual circumstances, and if it must terminate processing, it should do so in a graceful manner.
</br>•	Design is not coding, coding is not design. Even when detailed procedural designs are created for program components, the level of abstraction of the design model is higher than the source code. The only design decisions made at the coding level should address the small implementation details that enable the procedural design to be coded.
</br>•	The design should be assessed for quality as it is being created, not after the fact. A variety of design concepts and design measures are available to assist the designer in assessing quality throughout the development process.
</br>•	The design should be reviewed to minimize conceptual (semantic) errors. There is sometimes a tendency to focus on minutiae when the design is reviewed, missing the forest for the trees. A design team should ensure that major conceptual elements of the design (omissions, ambiguity, inconsistency) have been addressed before worrying about the syntax of the design model.</br>
<font size= 5>Que.5. Write about software testing fundamentals.</br>
Ans.</font> SOFTWARE TESTING BASICS is what this entire site is dedicated to. However, you need to first master the basics of the basics before you begin. So, we strongly recommend you to go through the following fundamental articles if you are just starting the journey into thg.
</br>BASICS OF THE BASICS
</br>Basics	Summary
</br>Learn how software quality is defined and what it means. Software quality is the degree of conformance to explicit or implicit requirements and expectations.
Dimensions of Quality
</br>Learn the dimensions of quality. Software quality has dimensions such as Accessibility, Compatibility, Concurrency, Efficiency …
Software Quality Assurance
</br>Learn what it means and what its relationship is with Software Quality Control.  Software Quality Assurance is a set of activities for ensuring quality in software engineering processes.
Software Quality Control
</br>Learn what it means and what its relationship is with Software Quality Assurance. Software Quality Control is a set of activities for ensuring quality in software products.
SQA and SQC Differences
</br>Learn the differences between Software Quality Assurance and Software Quality Control. SQA is process-focused and prevention-oriented but SQC is product-focused and detection-oriented.
Software Development Life Cycle
</br>Learn what SDLC means and what activities a typical SDLC model comprises of. Software Development Life Cycle defines the steps/stages/phases in the building of software.
Software Testing Life Cycle
</br>Learn what STLC means and what activities a typical STLC model comprises of. Software Testing Life Cycle (STLC) defines the steps/ stages/ phases in testing of software.
Definition of Test
</br>Learn the various definitions of the term ‘test’. Merriam Webster defines Test as “a critical examination, observation, or evaluation”.
Software Testing Myths </br>
                                                                	Just as every field has its myths, so does the field of Software Testing. We explain some of the myths along with their related facts</br>

                                 <div align= "center">   <font size= 5>   Section “ B ” </div>
Que.6. Write about software metrics.</br>
 
Ans.</font>Once measures are collected they are converted into metrics for use. IEEE defines metric as 'a quantitative measure of the degree to which a system, component, or process possesses a given attribute.' The goal of software metrics is to identify and control essential parameters that affect software development. Other objectives of using software metrics are listed below.
</br>•	Measuring the size of the software quantitatively.
</br>•	Assessing the level of complexity involved.
</br>•	Assessing the strength of the module by measuring coupling.
</br>•	Assessing the testing techniques.
</br>•	Specifying when to stop testing.
</br>•	Determining the date of release of the software.
</br>•	Estimating cost of resources and project schedule.
</br>Software metrics help project managers to gain an insight into the efficiency of the software process, project, and product. This is possible by collecting quality and productivity data and then analyzing and comparing these data with past averages in order to know whether quality improvements have occurred. Also, when metrics are applied in a consistent manner, it helps in project planning and project management activity. For example, schedule-based resource allocation can be effectively enhanced with the help of metrics.
Metrics is often used interchangeably with measure and measurement. However, it is important to note the differences between them. Measure can be defined as quantitative indication of amount, dimension, capacity, or size of product and process attributes. Measurement can be defined as the process of determining the measure. Metrics can be defined as quantitative measures that allow software engineers to identify the efficiency and improve the quality of software process, project, and product.
To understand the difference, let us consider an example. A measure is established when a number of errors is (single data point) detected in a software component. Measurement is the process of collecting one or more data points. In other words, measurement is established when many components are reviewed and tested individually to collect the measure of a number of errors in all these components. Metrics are associated with individual measure in some manner. That is, metrics are related to detection of errors found per review or the average number of errors found per unit test.
Once measures and metrics have been developed, indicators are obtained. These indicators provide a detailed insight into the software process, software project, or intermediate product. Indicators also enable software engineers or project managers to adjust software processes and improve software products, if required. For example, measurement dashboards or key indicators are used to monitor progress and initiate change. Arranged together, indicators provide snapshots of the system's performance.
Measured Data</br>
</br>Before data is collected and used, it is necessary to know the type of data involved in the software metrics. Table lists different types of data, which are identified in metrics along with their description and the possible operations that can be performed on them.
                                                 </br>     Type of Data Measured
</br>Type of data	Possible operations	Description of data
</br>Nominal	=,≠	Categories
</br>Ordinal	<, >	Ranking
</br>Interval	+, -	Differences
</br>Ratio	/	Absolute zero
</br>•	Nominal data: Data in the program can be measured by placing it under a category. This category of program can be a database program, application program, or an operating system program. For such data, operation of arithmetic type and ranking of values in any order (increasing or decreasing) is not possible. The only operation that can be performed is to determine whether program 'X' is the same as program 'Y'.
</br>•	Ordinal data: Data can be ranked according to the data values. For example, experience in application domain can be rated as very low, low, medium, or high. Thus, experience can easily be ranked according to its rating.
</br>•	Interval data: Data values can be ranked and substantial differences between them can also be shown. For example, a program with complexity level 8 is said to be 4 units more complex than a program with complexity level 4.
</br>•	Ratio data: Data values are associated with a ratio scale, which possesses an absolute zero and allows meaningful ratios to be calculated. For example, program lines expressed in lines of code.
</br>It is desirable to know  the measurement scale for metrics. For example, if metrics values are used to represent a model for a software process, then metrics associated with the ratio scale may be preferred.</br>
<font size= 5>
Que.7. Write about verification and validation.

 Ans.</font>Verification	</br>             Validation</br>


</br>1. Verification is a static practice of verifying documents, design, code and program.	</br>1. Validation is a dynamic mechanism of validating and testing the actual product.
</br>2. It does not involve executing the code.	</br>2. It always involves executing the code.
</br>3. It is human based checking of documents and files.	</br>3. It is computer based execution of program.
</br>4. Verification uses methods like inspections, reviews, walkthroughs, and Desk-checking etc.	</br>4. Validation uses methods like black box (functional)  testing, gray box testing, and white box (structural) testing etc.
</br>5. Verification is to check whether the software conforms to specifications.	</br>5. Validation is to check whether software meets the customer expectations and requirements.
</br>6. It can catch errors that validation cannot catch. It is low level exercise.	</br>6. It can catch errors that verification cannot catch. It is High Level Exercise.
</br>7. Target is requirements specification, application and software architecture, high level, complete design, and database design etc.	</br>7. Target is actual product-a unit, a module, a bent of integrated modules, and effective final product.
</br>8. Verification is done by QA team to ensure that the software is as per the specifications in the SRS document.	</br>8. Validation is carried out with the involvement of testing team.
</br>9. It generally comes first-done before validation.	</br>9. It generally follows after verification.</br>
 <font size= 5>
Que.8. Write about risk management risk.</br>
Ans.  </font>        Risk management means risk containment and mitigation. First, you’ve got to identify and plan. Then be ready to act when a risk arises, drawing upon the experience and knowledge of the entire team to minimize the impact to the project. 

</br>Risk management includes the following tasks:
</br>•	Identify risks and their triggers
<br>•	Classify and prioritize all risks
</br>•	Craft a plan that links each risk to a mitigation
</br>•	Monitor for risk triggers during the project
</br>•	Implement the mitigating action if any risk materializes
</br>•	Communicate risk status throughout project
</br>Identify and Classify Risks
</br>Most software engineering projects are inherently risky because of the variety potential problems that might arise. Experience from other software engineering projects can help managers classify risk. The importance here is not the elegance or range of classification, but rather to precisely identify and describe all of the real threats to project success. A simple but effective classification scheme is to arrange risks according to the areas of impact.
</br>Five Types of Risk In Software Project Management
</br>For most software development projects, we can define five main risk impact areas: 
</br>•	New, unproven technologies
</br>•	User and functional requirements
</br>•	Application and system architecture
</br>•	Performance
</br>•	Organizational
</br>New, unproven technologies. The majority of software projects entail the use of new technologies. Ever-changing tools, techniques, protocols, standards, and development systems increase the probability that technology risks will arise in virtually any substantial software engineering effort. Training and knowledge are of critical importance, and the improper use of new technology most often leads directly to project failure.
User and functional requirements. Software requirements capture all user needs with respect to the software system features, functions, and quality of service. Too often, the process of requirements definition is lengthy, tedious, and complex. Moreover, requirements usually change with discovery, prototyping, and integration activities. Change in elemental requirements will likely propagate throughout the entire project, and modifications to user requirements might not translate to functional requirements. These disruptions often lead to one or more critical failures of a poorly-planned software development project.
Application and system architecture. Taking the wrong direction with a platform, component, or architecture can have disastrous consequences. As with the technological risks, it is vital that the team includes experts who understand the architecture and have the capability to make sound design choices.
Performance. It’s important to ensure that any risk management plan encompasses user and partner expectations on performance. Consideration must be given to benchmarks and threshold testing throughout the project to ensure that the work products are moving in the right direction.
Organizational. Organizational problems may have adverse effects on project outcomes. Project management must plan for efficient execution of the project, and find a balance between the needs of the development team and the expectations of the customers. Of course, adequate staffing includes choosing team members with skill sets that are a good match with the project. 
Risk Management Plan
After cataloging all of the risks according to type, the software development project manager should craft a risk management plan. As part of a larger, comprehensive project plan, the risk management plan outlines the response that will be taken for each risk—if it materializes. 
Monitor and Mitigate
To be effective, software risk monitoring has to be integral with most project activities. Essentially, this means frequent checking during project meetings and critical events.
Monitoring includes.
</br>•	Publish project status reports and include risk management issues
</br>•	Revise risk plans according to any major changes in project schedule
</br>•	Review and reprioritize risks, eliminating those with lowest probability
</br>•	Brainstorm on potentially new risks after changes to project schedule or scope
</br>When a risk occurs, the corresponding mitigation response should be taken from the risk management plan.</br>
Mitigating options include:
</br>•	Accept: Acknowledge that a risk is impacting the project. Make an explicit decision to accept the risk without any changes to the project. Project management approval is mandatory here.
</br>•	Avoid: Adjust project scope, schedule, or constraints to minimize the effects of the risk. 
</br>•	Control: Take action to minimize the impact or reduce the intensification of the risk.
</br>•	Transfer: Implement an organizational shift in accountability, responsibility, or authority to other stakeholders that will accept the risk.
</br>•	Continue Monitoring: Often suitable for low-impact risks, monitor the project environment for potentially increasing impact of the risk.</br>
<font size= 5>Que.9. Write about data design.</br>
Ans. </font>Data design is the first design activity, which results in less complex, modular and efficient program structure. The information domain model developed during analysis phase is transformed into data structures needed for implementing the software. The data objects, attributes, and relationships depicted in entity relationship diagrams and the information stored in data dictionary provide a base for data design activity. During the data design process, data types are specified along with the integrity rules required for the data. For specifying and designing efficient data structures, some principles should be followed. These principles are listed below.
</br>1.	The data structures needed for implementing the software as well-as the operations that can be applied on them should be identified.
</br>2.	A data dictionary should be developed to depict how different data objects interact with each other and what constraints are to be imposed on the elements of data structure.
</br>3.	Stepwise refinement should be used in data design process and detailed design decisions should be made later in the process.
</br>4.	Only those modules that need to access data stored in a data structure directly should be aware of the representation of the data structure.
</br>5.	A library containing the set of useful data structures along with the operations that can be performed on them should be maintained.
</br>6.	Language used for developing the system should support abstract data types.
The structure of data can be viewed at three levels, namely, program component level, application level, and business level. At the program component level, the design of data structures and the algorithms required to manipulate them is necessary, if high-quality software is desired. At the application level, it is crucial to convert the data model into a database so that the specific business objectives of a system could be achieved. At the business level, the collection of information stored in different databases should be reorganized into data warehouse, which enables data mining that an influential impact on the business.</br>
<font size= 5>
Que.10. Write about SCM process.</br>
Ans.</font> Definition - What does Software Configuration Management (SCM) mean
</br>Software configuration management (SCM) is a software engineering discipline consisting of standard processes and techniques often used by organizations to manage the changes introduced to its software products. SCM helps in identifying individual elements and configurations, tracking changes, and version selection, control, and baselining.

</br>SCM is also known as software control management. SCM aims to control changes introduced to large complex software systems through reliable version selection and version control.
Techopedia explains Software Configuration Management (SCM)</br>
</br>SCM defines a mechanism to deal with different technical difficulties of a project plan. In a software organization, effective implementation of software configuration management can improve productivity by increased coordination among the programmers in a team. SCM helps to eliminate the confusion often caused by miscommunication among team members. The SCM system controls the basic components such as software objects, program code, test data, test output, design documents, and user manuals.

</br>The SCM system has the following advantages: 
</br>•	Reduced redundant work.
</br>•	Effective management of simultaneous updates.
</br>•	Avoids configuration-related problems.
</br>•	Facilitates team coordination.
</br>•	Helps in building management; managing tools used in builds.
</br>•	Defect tracking: It ensures that every defect has traceability back to its source.

</div> 
</body>
</html>                                           

                            





