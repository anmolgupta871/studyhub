<html>
<body>
<div align="justify">
<center>
<h2>  B.C.A. 6th Semester (New/ATKT)</br>
                 Examination,2013</br>
                 
Software Engineering 2013
</h2></center>
</br><font size="5">         
   

Note Attempt all questions. </br>
         <center> Section A </br>
(Objective Type Questions) </center></br>
</br>
Q1 .  Choose the correct answer- </font></br>
(i)Parallul teams are rcquired in: </br>
(a) RAD model (b) Meta modci (c) Spiral model (d) None of the abovc </br>
(ii) Software tesling is given by an equation: </br>
(a) Verification validation </br>
(b) Verification validation online BU com</br>
 (c) Verification/validation</br>
 (d) None of the above </br>
(iii) The most important task in a soltwaru projuct is: </br>
(a) implementation </br>
(b) Controlling</br>
 (c) Closing</br>
 (d) Planning </br>
(iv) In Mc Call quality model, product revision quality ractor consist of: </br>
(a) Maintainability </br>
(b) Flexibility </br>
(c) Testability </br>
(d) None of thc above </br>
(v) Alpha testing is done by: </br>
(a) Tesler</br>
 (b) Customer </br>
(c) Developer </br>
(d) All of the above </br>

</br>   <font size="5">    <center>   Section-B </br>
(Short Answer Type Questions) </br></center>

</br>Q2. What is the basic difference between RAD model and Incremental model? </br>
        or </br>
How many types of metrics aru thcrc? Explain in brief?</br>

Ans:-</font>Unsuccessful app development projects are not anything new. It happened to one of my friends who was trying to get a suitable app for his business. He got in touch with one of the reputed mobile development companies to start the process. But whole development took him a month, as the development company followed the incremental app development model instead of RAD process model. On the other hand, the app could not stand long in the market, which cost him his brand image and a lot of money!

I think that this can happen to any organization that put an app on the market right away without software testing. Running a test on software applications is crucial as it helps you verify whether the app developed is suitable for the market. You can also find software bugs quickly and take necessary actions.

When it comes to software testing, incremental model and RAD model differ to a great extent. As per my recent research, RAD model is more facilitating toward app testing than the incremental model. I have tried to provide different parameters below, to help you understand the major differences between these two models in software testing:

App Flexibility and Productivity: Linear approaches to app development has been always rigid. When you try to develop all features at once, your project will inevitably lose its direction. Needless to say, there are long periods of waiting to get the app. By the time the app hits the market, it has already lost its relevance. RAD process model, on the other hand, helps you bring modifications in the features of the app from time to time, as per the feedback received from the users. Companies like HokuApps following the RAD model can keep the app always functional and productive, yet open to multiple iterations, whenever you need it. The app gets constantly tested and modified with RAD process model till it is perfect.

App Development Cycle: For companies following the incremental model, getting a fully developed app might take months. In worst cases, the app development cycle can be never-ending, as developers keep reworking on the app, leading to high maintenance costs and wastage. RAD process model simplifies app development by introducing multiple iterations. Besides, unlike incremental model that can be handled by only skilled developers, the IT and functional departments can work together with the RAD model. This fills in gaps in the development model. As a result, there will be fewer bugs than you can expect, which can be eliminated with constant app testing cycles of RAD model.

Test Automation: There is no automated software testing facility in incremental models. You can expect a testing only after the app has gone past through the coding phase. If you found some bugs or some performance issues, you need to rework on the coding to get it right, and it is going to take a lot of your profit and productivity. I rather prefer the RAD process model that allows test automation for a wide variety of devices and form factors after each iteration phase. Thus, you can ensure a market-ready app for your business.

</br>
</br>
<font size="5"> 
 Q3 . Briefly describe requirement review and its type </br>
         or</br>
 What is SRS? Also write its components?</br>

Ans:-</font>In the software development process, requirement phase is the first software engineering activity. This phase is a user-dominated phase and translates the ideas or views into a requirements document. Note that defining and documenting the user requirements in a concise and unambiguous manner is the first major step to achieve a high-quality product.

The requirement phase encompasses a set of tasks, which help to specify the impact of the software on the organization, customers' needs, and how users will interact with the developed software. The requirements are the basis of the system design. If requirements are not correct the end product will also contain errors. Note that requirements activity like all other software engineering activities should be adapted to the needs of the process, the project, the product and the people involved in the activity. Also, the requirements should be specified at different levels of detail. This is because requirements are meant for people such as users, business managers, system engineers, and so on. For example, business managers are interested in knowing which features can be implemented within the allocated budget whereas end-users are interested in knowing how easy it is to use the features of software.

What is Software Requirement?</br>

Requirement is a condition or capability possessed by the software or system component in order to solve a real world problem. The problems can be to automate a part of a system, to correct shortcomings of an existing system, to control a device, and so on. IEEE defines requirement as (1) A condition or capability needed by a user to solve a problem or achieve an objective. (2) A condition or capability that must be met or possessed by a system or system component to satisfy a contract, standard, specification, or other formally imposed documents. (3) A documented representation of a condition or capability as in (1) or (2).’

Requirements describe how a system should act, appear or perform. For this, when users request for software, they provide an approximation of what the new system should be capable of doing. Requirements differ from one user to another and from one business process to another.

Guidelines for Expressing Requirements

The purpose of the requirements document is to provide a basis for the mutual understanding between the users and the designers of the initial definition of the software development life cycle (SDLC) including the requirements, operating environment and development plan.

The requirements document should include the overview, the proposed methods and procedures, a summary of improvements, a summary of impacts, security, privacy, internal control considerations, cost considerations, and alternatives. The requirements section should state the functions required in the software in quantitative and qualitative terms and how these functions will satisfy the performance objectives. The requirements document should also specify the performance requirements such as accuracy, validation, timing, and flexibility. Inputs, outputs, and data characteristics need to be explained. Finally, the requirements document needs to describe the operating environment and provide (or make reference to) a development plan.

</br>
</br>
</br>
<font size="5"> 

Q4. What is Mc Call's Quality facor?</br>
    or </br>
inc different levels or CocoMo model? </br>
ans:-</font>Jim McCall produced this model for the US Air Force and the intention was to bridge the gap between users and developers. He tried to map the user view with the developer's priority. 

McCall identified three main perspectives for characterizing the quality attributes of a software product. 

These perspectives are:-Product revision (ability to change).Product transition (adaptability to new environments).Product operations (basic operational characteristics).Product revision 
The product revision perspective identifies quality factors that influence the ability to change the software product, these factors are:-Maintainability, the ability to find and fix a defect.Flexibility, the ability to make changes required as dictated by the business.Testability, the ability to Validate the software requirements.Product transition 
The product transition perspective identifies quality factors that influence the ability to adapt the software to new environments:-Portability, the ability to transfer the software from one environment to another.Reusability, the ease of using existing software components in a different context.Interoperability, the extent, or ease, to which software components work together.Product operations 
The product operations perspective identifies quality factors that influence the extent to which the software fulfils its specification:-Correctness, the functionality matches the specification.Reliability, the extent to which the system fails.Efficiency, system resource (including cpu, disk, memory, network) usage.Integrity, protection from unauthorized access.Usability, ease of use.In total McCall identified the 11 quality factors broken down by the 3 perspectives, as listed above. 
For each quality factor McCall defined one or more quality criteria (a way of measurement), in this way an overall quality assessment could be made of a given software product by evaluating the criteria for each factor. 
For example the Maintainability quality factor would have criteria of simplicity, conciseness and modularity. 

</br>
</br><font size="5"> </br>
Q5. Distinguish between cohesion and coupling?         
</br>
                or </br>
What is verification? Also, write down metrics used for this. </br>
Ans:-</font>Coupling vs Cohesion 

Coupling and cohesion are two concepts found in Java (and all other object oriented languages). Coupling measures how much each of the program modules are dependent on the other program modules. Cohesion measures how strongly each of the functions are related within a module. Actually, any object oriented language (including Java) has the two main objectives of increasing cohesiveness and decreasing the coupling at the same time, in order to develop most efficient programmes. These two software engineering metrics were developed by Larry Constantine to reduce the cost of modifying and maintaining software.

What is Cohesion?

Cohesion measures how strongly each of the functions are related within a program module. Well structured classes lead to highly cohesive programs. If a certain class is performing a set of highly related functions, that class is said to be cohesive. On the other hand, if a class is performing a bunch of totally unrelated functionalities that means the class is not cohesive at all. It is important to understand that not having cohesiveness does not mean that the overall application does not have the required functionality. It’s just that without cohesion, it will be very difficult to mange the functionality because they will be scattered in many wrong places as the complexity of the application increases over time. Maintaining, modifying and extending behaviors scattered all over the code is very tedious even for the most experience programmers.

What is Coupling?

Coupling measures how much each of the program modules are dependent on the other program modules. Interactions between two objects occur because there is coupling. Loosely-coupled programs are high in flexibility and extensibility. Strong coupling is never good because one object can be highly dependent on some other object. This is a nightmare when the code is modified, because high coupling means that the programmers need to work on several places of code for even a single behavioral modification. Strong coupling always leads to programs with low flexibility and less scalability/extensibility. However, in programming languages like Java, completely avoiding coupling is impossible. But it is recommended that the programmers give their best effort to reduce the coupling as much as possible. It is also possible to have some coupling to help objects interact with each other without hampering its scalability and flexibility.

What is the difference between Coupling and Cohesion?

Even though coupling and cohesion deal with the quality of a module in software engineering, they are entirely different concepts. Cohesion talks about how much the functionality are related to each other within the module, while coupling deals with how much one module is dependent on the other program modules within the whole application. In order to have the best quality software, cohesion and coupling should reach the two opposite ends of their spectrums. In other words, loose coupling and strong cohesion provides the best software. Having private fields, non-public classes and private methods provide loose-coupling, while making all members visible within the class and having package as the default visibility provide high cohesion.

</br>
</br><font size="5"> 
Q6. Why status accounting is required?</br>
 or </br>
How many types of system tesuing are there? </br>    
ans:-</font>Naturally, the team selects that group of tests that make the most sense in the circumstances.

Acceptance Testing: Formal testing conducted to determine whether or not a system satisfies its acceptance criteria and to enable the customer to determine whether or not to accept the system. This testing process is usually performed by customer representatives.

Accessibility Testing: Type of testing which determines the usability of a product to the people having disabilities (deaf, blind, mentally disabled, etc.). The evaluation process should be conducted by persons with disabilities.

Active Testing: Type of testing consisting in introducing test data and analyzing the execution results. This testing process is usually conducted by the testing teams.

Agile Testing: A software testing practice that follows the principles of the agile manifesto, emphasizing testing from the perspective of customers who will utilize the system. This type of testing is usually performed by QA teams.

Age Testing: Type of testing which evaluates a system’s ability to perform in the future. The evaluation process is conducted by testing teams.

Ad-hoc Testing: Testing performed without planning and documentation – the tester tries to ‘break’ the system by randomly trying the system’s functionality. This testing process is performed by testing teams.

Alpha Testing: Type of testing a software product or system conducted at the developer’s site. This testing process is usually performed by the end user.

Assertion Testing: Type of testing consisting in verifying if the conditions confirm the product requirements. This type of testing is performed by the testing teams.

API Testing: Testing technique similar to unit testing in that it targets the code level. API testing differs from unit testing in that it is typically a QA task and not a developer task.

All-pairs Testing: Combinatorial testing method that tests all possible discrete combinations of input parameters. This testing process is usually performed by the testing teams.

Automated Testing: Testing technique that uses automation testing tools to control the environment set-up, test execution and results reporting. This testing process is performed by a computer and is used inside the testing teams.

Basis Path Testing: A testing mechanism which derives a logical complexity measure of a procedural design and is used this as a guide for defining a basic set of execution paths. This testing process is normally used by testing teams when defining test cases.

Backward Compatibility Testing: A testing method which verifies the behavior of the developed software with older versions of the test environment. This testing process is performed by testing teams.

Beta Testing: Final testing before releasing application for commercial purpose. This testing process is typically done by end-users or others.

Benchmark Testing: Testing technique that uses representative sets of programs and data designed to evaluate the performance of computer hardware and software in a given configuration. This testing process is performed by testing teams.

Big Bang Integration Testing: A testing technique which integrates individual program modules only when everything is ready. This testing process is performed by the testing teams.

Binary Portability Testing: Technique that tests an executable application for portability across system platforms and environments, usually for conformation to an ABI specification. This testing process is performed by the testing teams.

Boundary Value Testing: Software testing technique in which tests are designed to include representatives of boundary values. It is performed by the QA testing teams.

Bottom Up Integration Testing: In bottom up integration testing, module at the lowest level are developed first and other modules which go towards the ‘main’ program are integrated and tested one at a time. This testing process is usually performed by the testing teams.

Branch Testing: Testing technique in which all branches in the program source code are tested at least once. This is done by the developer.

Breadth Testing: A test suite that exercises the full functionality of a product but does not test features in detail. This testing process is performed by testing teams.

Black box Testing: A method of software testing that verifies the functionality of an application without having specific knowledge of the application’s code/internal structure. Tests are based on requirements and functionality. This testing process is performed by QA teams.

Code-driven Testing: Testing technique that uses testing frameworks (such as x Unit) that allow the execution of unit tests to determine whether various sections of the code are acting as expected under various circumstances. This testing process is performed by the development teams.

Compatibility Testing: Testing technique that validates how well a software performs in a particular hardware/software/operating system/network environment. This testing process is performed by the testing teams.

Comparison Testing: Testing technique which compares the product strengths and weaknesses with previous versions or other similar products. Can be performed by tester, developers, product managers or product owners.

</br>
</br>
  <font size="5"> 
    <center>  Section C</br>
	(Long Answer Type Questions)</center></br>
Q7. Define Software Engineering? Compare prototype model with</br>
 spiral model of software.</br>
        or </br>
what is project management? How functionality of a softwaru is calculated? 
ans:- </font>The spiral model combines the idea of iterative development with the systematic, controlled aspects of the waterfall model. This Spiral model is a combination of iterative development process model and sequential linear development model i.e. the waterfall model with a very high emphasis on risk analysis. It allows incremental releases of the product or incremental refinement through each iteration around the spiral.

Spiral Model - Design

The spiral model has four phases. A software project repeatedly passes through these phases in iterations called Spirals.

Identification

This phase starts with gathering the business requirements in the baseline spiral. In the subsequent spirals as the product matures, identification of system requirements, subsystem requirements and unit requirements are all done in this phase.

This phase also includes understanding the system requirements by continuous communication between the customer and the system analyst. At the end of the spiral, the product is deployed in the identified market.

Design

The Design phase starts with the conceptual design in the baseline spiral and involves architectural design, logical design of modules, physical product design and the final design in the subsequent spirals.

Construct or Build

The Construct phase refers to production of the actual software product at every spiral. In the baseline spiral, when the product is just thought of and the design is being developed a POC (Proof of Concept) is developed in this phase to get customer feedback.

Then in the subsequent spirals with higher clarity on requirements and design details a working model of the software called build is produced with a version number. These builds are sent to the customer for feedback.

Evaluation and Risk Analysis

Risk Analysis includes identifying, estimating and monitoring the technical feasibility and management risks, such as schedule slippage and cost overrun. After testing the build, at the end of first iteration, the customer evaluates the software and provides feedback.

The following illustration is a representation of the Spiral Model, listing the activities in each phase.

￼

Based on the customer evaluation, the software development process enters the next iteration and subsequently follows the linear approach to implement the feedback suggested by the customer. The process of iterations along the spiral continues throughout the life of the software.

Spiral Model Application

The Spiral Model is widely used in the software industry as it is in sync with the natural development process of any product, i.e. learning with maturity which involves minimum risk for the customer as well as the development firms.

The following pointers explain the typical uses of a Spiral Model −

When there is a budget constraint and risk evaluation is important.

For medium to high-risk projects.

Long-term project commitment because of potential changes to economic priorities as the requirements change with time.

Customer is not sure of their requirements which is usually the case.

Requirements are complex and need evaluation to get clarity.

New product line which should be released in phases to get enough customer feedback.

Significant changes are expected in the product during the development cycle.

Spiral Model - Pros and Cons

The advantage of spiral lifecycle model is that it allows elements of the product to be added in, when they become available or known. This assures that there is no conflict with previous requirements and design.

This method is consistent with approaches that have multiple software builds and releases which allows making an orderly transition to a maintenance activity. Another positive aspect of this method is that the spiral model forces an early user involvement in the system development effort.

On the other side, it takes a very strict management to complete such products and there is a risk of running the spiral in an indefinite loop. So, the discipline of change and the extent of taking change requests is very important to develop and deploy the product successfully.

The advantages of the Spiral SDLC Model are as follows −

Changing requirements can be accommodated.

Allows extensive use of prototypes.

Requirements can be captured more accurately.

Users see the system early.

Development can be divided into smaller parts and the risky parts can be developed earlier which helps in better risk management.

The disadvantages of the Spiral SDLC Model are as follows −

Management is more complex.

End of the project may not be known early.

Not suitable for small or low risk projects and could be expensive for small projects.

Process is complex

Spiral may go on indefinitely.

Large number of intermediate stages requires excessive documentation.


</br>
<font size="5"> 
</br>
Q8. Explain process steps of requirement engincuring with a suitable diagram. </br>
   or</br>
 How information mudeling is donc in a software, explain with an example.</br>
ans:-</font>The software requirements are description of features and functionalities of the target system. Requirements convey the expectations of users from the software product. The requirements can be obvious or hidden, known or unknown, expected or unexpected from client’s point of view.

Requirement Engineering</br>

The process to gather the software requirements from client, analyze and document them is known as requirement engineering.

The goal of requirement engineering is to develop and maintain sophisticated and descriptive ‘System Requirements Specification’ document.

Requirement Engineering Process

It is a four step process, which includes –

Feasibility StudyRequirement GatheringSoftware Requirement SpecificationSoftware Requirement Validation

Let us see the process briefly -
</br>
Feasibility study
</br>
When the client approaches the organization for getting the desired product developed, it comes up with rough idea about what all functions the software must perform and which all features are expected from the software.

Referencing to this information, the analysts does a detailed study about whether the desired system and its functionality are feasible to develop.

This feasibility study is focused towards goal of the organization. This study analyzes whether the software product can be practically materialized in terms of implementation, contribution of project to organization, cost constraints and as per values and objectives of the organization. It explores technical aspects of the project and product such as usability, maintainability, productivity and integration ability.

The output of this phase should be a feasibility study report that should contain adequate comments and recommendations for management about whether or not the project should be undertaken.
</br>
Requirement Gathering
</br>
If the feasibility report is positive towards undertaking the project, next phase starts with gathering requirements from the user. Analysts and engineers communicate with the client and end-users to know their ideas on what the software should provide and which features they want the software to include.
</br>
Software Requirement Specification
</br>
SRS is a document created by system analyst after the requirements are collected from various stakeholders.

SRS defines how the intended software will interact with hardware, external interfaces, speed of operation, response time of system, portability of software across various platforms, maintainability, speed of recovery after crashing, Security, Quality, Limitations etc.

The requirements received from client are written in natural language. It is the responsibility of system analyst to document the requirements in technical language so that they can be comprehended and useful by the software development team.

SRS should come up with following features:

User Requirements are expressed in natural language.Technical requirements are expressed in structured language, which is used inside the organization.Design description should be written in Pseudo code.Format of Forms and GUI screen prints.Conditional and mathematical notations for DFDs etc.
</br>
Software Requirement Validation
</br>
After requirement specifications are developed, the requirements mentioned in this document are validated. User might ask for illegal, impractical solution or experts may interpret the requirements incorrectly. This results in huge increase in cost if not nipped in the bud. Requirements can be checked against following conditions -

If they can be practically implementedIf they are valid and as per functionality and domain of softwareIf there are any ambiguitiesIf they are completeIf they can be demonstrated

Requirement Elicitation Process

Requirement elicitation process can be depicted using the folloiwng diagram:

￼Requirements gathering - The developers discuss with the client and end users and know their expectations from the software.Organizing Requirements - The developers prioritize and arrange the requirements in order of importance, urgency and convenience.

Negotiation & discussion - If requirements are ambiguous or there are some conflicts in requirements of various stakeholders, if they are, it is then negotiated and discussed with stakeholders. Requirements may then be prioritized and reasonably compromised.

The requirements come from various stakeholders. To remove the ambiguity and conflicts, they are discussed for clarity and correctness. Unrealistic requirements are compromised reasonably.

Documentation - All formal & informal, functional and non-functional requirements are documented and made available for next phase processing.

Requirement Elicitation Techniques

Requirements Elicitation is the process to find out the requirements for an intended software system by communicating with client, end users, system users and others who have a stake in the software system development.

There are various ways to discover requirements

Interviews

Interviews are strong medium to collect requirements. Organization may conduct several types of interviews such as:

Structured (closed) interviews, where every single information to gather is decided in advance, they follow pattern and matter of discussion firmly.Non-structured (open) interviews, where information to gather is not decided in advance, more flexible and less biased.Oral interviewsWritten interviewsOne-to-one interviews which are held between two persons across the table.Group interviews which are held between groups of participants. They help to uncover any missing requirement as numerous people are involved.

</br></br><font size="5"> 
Q9. What is software quality assurance? Give a comparative analysis of external versus internal qualitics? </br>
       Or </br>
management activity? </br>
ans:-</font>
The job pattern of an IT company engaged in software development can be seen split in two parts:

Software CreationSoftware Project Management

A project is well-defined task, which is a collection of several operations done in order to achieve a goal (for example, software development and delivery). A Project can be characterized as:

Every project may has a unique and distinct goal.Project is not routine activity or day-to-day operations.Project comes with a start time and end time.Project ends when its goal is achieved hence it is a temporary phase in the lifetime of an organization.Project needs adequate resources in terms of time, manpower, finance, material and knowledge-bank.

Software Project

A Software Project is the complete procedure of software development from requirement gathering to testing and maintenance, carried out according to the execution methodologies, in a specified period of time to achieve intended software product.

Need of software project management

Software is said to be an intangible product. Software development is a kind of all new stream in world business and there’s very little experience in building software products. Most software products are tailor made to fit client’s requirements. The most important is that the underlying technology changes and advances so frequently and rapidly that experience of one product may not be applied to the other one. All such business and environmental constraints bring risk in software development hence it is essential to manage software projects efficiently.

￼

The image above shows triple constraints for software projects. It is an essential part of software organization to deliver quality product, keeping the cost within client’s budget constrain and deliver the project as per scheduled. There are several factors, both internal and external, which may impact this triple constrain triangle. Any of three factor can severely impact the other two.

Therefore, software project management is essential to incorporate user requirements along with budget and time constraints.

Software Project Manager

A software project manager is a person who undertakes the responsibility of executing the software project. Software project manager is thoroughly aware of all the phases of SDLC that the software would go through. Project manager may never directly involve in producing the end product but he controls and manages the activities involved in production.

A project manager closely monitors the development process, prepares and executes various plans, arranges necessary and adequate resources, maintains communication among all team members in order to address issues of cost, budget, resources, time, quality and customer satisfaction.

Let us see few responsibilities that a project manager shoulders -

Managing People

Act as project leaderLiaison with stakeholdersManaging human resourcesSetting up reporting hierarchy etc.

Managing Project

Defining and setting up project scopeManaging project management activitiesMonitoring progress and performanceRisk analysis at every phaseTake necessary step to avoid or come out of problemsAct as project spokesperson

Software Management Activities

Software project management comprises of a number of activities, which contains planning of project, deciding scope of software product, estimation of cost in various terms, scheduling of tasks and events, and resource management. Project management activities may include:

Project PlanningScope ManagementProject Estimation

Project Planning

Software project planning is task, which is performed before the production of software actually starts. It is there for the software production but involves no concrete activity that has any direction connection with software production; rather it is a set of multiple processes, which facilitates software production. Project planning may include the following:

Scope Management

It defines the scope of project; this includes all the activities, process need to be done in order to make a deliverable software product. Scope management is essential because it creates boundaries of the project by clearly defining what would be done in the project and what would not be done. This makes project to contain limited and quantifiable tasks, which can easily be documented and in turn avoids cost and time overrun.

During Project Scope management, it is necessary to -

Define the scopeDecide its verification and controlDivide the project into various smaller parts for ease of management.Verify the scopeControl the scope by incorporating changes to the scope

Project Estimation

For an effective management accurate estimation of various measures is a must. With correct estimation managers can manage and control the project more efficiently and effectively.

Project estimation may involve the following:

Software size estimation

Software size may be estimated either in terms of KLOC (Kilo Line of Code) or by calculating number of function points in the software. Lines of code depend upon coding practices and Function points vary according to the user or software requirement.

Effort estimation

The managers estimate efforts in terms of personnel requirement and man-hour required to produce the software. For effort estimation software size should be known. This can either be derived by managers’ experience, organization’s historical data or software size can be converted into efforts by using some standard formulae.

Time estimation

Once size and efforts are estimated, the time required to produce the software can be estimated. Efforts required is segregated into sub categories as per the requirement specifications and interdependency of various components of software. Software tasks are divided into smaller tasks, activities or events by Work Breakthrough Structure (WBS). The tasks are scheduled on day-to-day basis or in calendar months.

The sum of time required to complete all tasks in hours or days is the total time invested to complete the project.

Cost estimation

This might be considered as the most difficult of all because it depends on more elements than any of the previous ones. For estimating project cost, it is required to consider -

Size of softwareSoftware qualityHardwareAdditional software or tools, licenses etc.Skilled personnel with task-specific skillsTravel involvedCommunicationTraining and support.

</br>
</br><font size="5"> 
Q10. What do you mean by design objectives? Explain various design principles involved in design-engineering of a sofware.</br> 
       or</br>
 What are design classes? How functional indcpcndence can bc achieved in designing a software? </br>
ans:-</font>Once the requirements document for the software to be developed is available, the software design phase begins. While the requirement specification activity deals entirely with the problem domain, design is the first phase of transforming the problem into a solution. In the design phase, the customer and business requirements and technical considerations all come together to formulate a product or a system.

The design process comprises a set of principles, concepts and practices, which allow a software engineer to model the system or product that is to be built. This model, known as design model, is assessed for quality and reviewed before a code is generated and tests are conducted. The design model provides details about software data structures, architecture, interfaces and components which are required to implement the system. This chapter discusses the design elements that are required to develop a software design model. It also discusses the design patterns and various software design notations used to represent a software design.
</br>
Basic of Software Design
</br>
Software design is a phase in software engineering, in which a blueprint is developed to serve as a base for constructing the software system. IEEEdefines software design as 'both a process of defining, the architecture, components, interfaces, and other characteristics of a system or component and the result of that process.'

In the design phase, many critical and strategic decisions are made to achieve the desired functionality and quality of the system. These decisions are taken into account to successfully develop the software and carry out its maintenance in a way that the quality of the end product is improved.

Principles of Software Design

Developing design is a cumbersome process as most expansive errors are often introduced in this phase. Moreover, if these errors get unnoticed till later phases, it becomes more difficult to correct them. Therefore, a number of principles are followed while designing the software. These principles act as a framework for the designers to follow a good design practice.

                                 ￼

Some of the commonly followed design principles are as following. 

Software design should correspond to the analysis model: Often a design element corresponds to many requirements, therefore, we must know how the design model satisfies all the requirements represented by the analysis model.Choose the right programming paradigm: A programming paradigm describes the structure of the software system. Depending on the nature and type of application, different programming paradigms such as procedure oriented, object-oriented, and prototyping paradigms can be used. The paradigm should be chosen keeping constraints in mind such as time, availability of resources and nature of user's requirements.Software design should be uniform and integrated: Software design is considered uniform and integrated, if the interfaces are properly defined among the design components. For this, rules, format, and styles are established before the design team starts designing the software.Software design should be flexible:Software design should be flexible enough to adapt changes easily. To achieve the flexibility, the basic design concepts such as abstraction, refinement, and modularity should be applied effectively.Software design should ensure minimal conceptual (semantic) errors: The design team must ensure that major conceptual errors of design such as ambiguousness and inconsistency are addressed in advance before dealing with the syntactical errors present in the design model.Software design should be structured to degrade gently: Software should be designed to handle unusual changes and circumstances, and if the need arises for termination, it must do so in a proper manner so that functionality of the software is not affected.Software design should represent correspondence between the software and real-world problem: The software design should be structured in such away that it always relates with the real-world problem.Software reuse: Software engineers believe on the phrase: 'do not reinvent the wheel'. Therefore, software components should be designed in such a way that they can be effectively reused to increase the productivity.Designing for testability: A common practice that has been followed is to keep the testing phase separate from the design and implementation phases. That is, first the software is developed (designed and implemented) and then handed over to the testers who subsequently determine whether the software is fit for distribution and subsequent use by the customer. However, it has become apparent that the process of separating testing is seriously flawed, as if any type of design or implementation errors are found after implementation, then the entire or a substantial part of the software requires to be redone. Thus, the test engineers should be involved from the initial stages. For example, they should be involved with analysts to prepare tests for determining whether the user requirements are being met.Prototyping: Prototyping should be used when the requirements are not completely defined in the beginning. The user interacts with the developer to expand and refine the requirements as the development proceeds. Using prototyping, a quick 'mock-up' of the system can be developed. This mock-up can be used as a effective means to give the users a feel of what the system will look like and demonstrate functions that will be included in the developed system. Prototyping also helps in reducing risks of designing software that is not in accordance with the customer's requirements.

Note that design principles are often constrained by the existing hardware configuration, the implementation language, the existing file and data structures, and the existing organizational practices. Also, the evolution of each software design should be meticulously designed for future evaluations, references and maintenance.

Software Design Concepts 

Every software process is characterized by basic concepts along with certain practices or methods. Methods represent the manner through which the concepts are applied. As new technology replaces older technology, many changes occur in the methods that are used to apply the concepts for the development of software. However, the fundamental concepts underlining the software design process remain the same, some of which are described here.


</br>
</br><font size="5"> 
  Qxl. Describe SCM process steps with a suitable diagram.</br> 
    or </font>
  Distinguish betwccn: (i) White Box and Black Box uesting, (ii) Integration System testing

WHITE BOX TESTING (also known as Clear Box Testing, Open Box Testing, Glass Box Testing, Transparent Box Testing, Code-Based Testing or Structural Testing) is a software testing method in which the internal structure/design/implementation of the item being tested is known to the tester. The tester chooses inputs to exercise paths through the code and determines the appropriate outputs. Programming know-how and the implementation knowledge is essential. White box testing is testing beyond the user interface and into the nitty-gritty of a system.

This method is named so because the software program, in the eyes of the tester, is like a white/transparent box; inside which one clearly sees.

Definition by ISTQB

white-box testing: Testing based on an analysis of the internal structure of the component or system.white-box test design technique:Procedure to derive and/or select test cases based on an analysis of the internal structure of a component or system.

Example

A tester, usually a developer as well, studies the implementation code of a certain field on a webpage, determines all legal (valid and invalid) AND illegal inputs and verifies the outputs against the expected outcomes, which is also determined by studying the implementation code.

White Box Testing is like the work of a mechanic who examines the engine to see why the car is not moving.


BLACK BOX TESTING, also known as Behavioral Testing, is a software testing method in which the internal structure/design/implementation of the item being tested is not known to the tester. These tests can be functional or non-functional, though usually functional.


This method is named so because the software program, in the eyes of the tester, is like a black box; inside which one cannot see. This method attempts to find errors in the following categories:

Incorrect or missing functionsInterface errorsErrors in data structures or external database accessBehavior or performance errorsInitialization and termination errors

Definition by ISTQB

black box testing: Testing, either functional or non-functional, without reference to the internal structure of the component or system.black box test design technique:Procedure to derive and/or select test cases based on an analysis of the specification, either functional or non-functional, of a component or system without reference to its internal structure.

Example

A tester, without knowledge of the internal structures of a website, tests the web pages by using a browser; providing inputs (clicks, keystrokes) and verifying the outputs against the expected outcome.

INTEGRATION TESTING is a level of software testing where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units. Test drivers and test stubs are used to assist in Integration Testing.

￼

Definition by ISTQB

integration testing: Testing performed to expose defects in the interfaces and in the
interactions between integrated components or systems. See also component integration
testing, system integration testing.component integration testing:Testing performed to expose defects in the interfaces and
interaction between integrated components.system integration testing: Testing the integration of systems and packages; testing
interfaces to external organizations (e.g. Electronic Data Interchange, Internet).

Analogy

During the process of manufacturing a ballpoint pen, the cap, the body, the tail and clip, the ink cartridge and the ballpoint are produced separately and unit tested separately. When two or more units are ready, they are assembled and Integration Testing is performed. For example, whether the cap fits into the body or not.

Method

Any of Black Box Testing, White Box Testing and Gray Box Testing methods can be used. Normally, the method depends on your definition of ‘unit’.

Tasks

Integration Test PlanPrepareReviewReworkBaselineIntegration Test Cases/ScriptsPrepareReviewReworkBaselineIntegration TestPerform

When is Integration Testing performed?

Integration Testing is the second level of testing performed after Unit Testing and before System Testing.

Who performs Integration Testing?

Developers themselves or independent testers perform Integration Testing.

Approaches

Big Bang is an approach to Integration Testing where all or most of the units are combined together and tested at one go. This approach is taken when the testing team receives the entire software in a bundle. So what is the difference between Big Bang Integration Testing and System Testing? Well, the former tests only the interactions between the units while the latter tests the entire system.Top Down is an approach to Integration Testing where top-level units are tested first and lower level units are tested step by step after that. This approach is taken when top-down development approach is followed. Test Stubs are needed to simulate lower level units which may not be available during the initial phases.Bottom Up is an approach to Integration Testing where bottom level units are tested first and upper-level units step by step after that. This approach is taken when bottom-up development approach is followed. Test Drivers are needed to simulate higher level units which may not be available during the initial phases.Sandwich/Hybrid is an approach to Integration Testing which is a combination of Top Down and Bottom Up approaches.


</div>
</body>
</html>