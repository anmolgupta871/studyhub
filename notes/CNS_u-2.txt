NETWORK AND INFORMATION SECURITY




BCA 6TH SEM NOTES UNIT 2






WHAT IS CRYPTOGRAPHY?


The word cryptography comes from the Greek words κρυπτο (hidden or secret) and γραφη (writing). Oddly enough, cryptography is the art of secret writing. More generally, people think of cryptography as the art of mangling information into apparent unintelligibility in a manner allow-ing a secret method of unmangling. The basic service provided by cryptography is the ability to send information between participants in a way that prevents others from reading it. In this book we will concentrate on the kind of cryptography that is based on representing information as numbers and mathematically manipulating those numbers. This kind of cryptography can provide other ser-vices, such as

•	integrity checking—reassuring the recipient of a message that the message has not been altered since it was generated by a legitimate source

•	authentication—verifying someone’s (or something’s) identity

But back to the traditional use of cryptography. A message in its original form is known as plaintext or cleartext. The mangled information is known as ciphertext. The process for produc-ing ciphertext from plaintext is known as encryption. The reverse of encryption is called decryp-tion.

encryption	decryption
plaintext   ciphertext   plaintext

While cryptographers invent clever secret codes, cryptanalysts attempt to break these codes. These two disciplines constantly try to keep ahead of each other.


Cryptographic systems tend to involve both an algorithm and a secret value. The secret value is known as the key. The reason for having a key in addition to an algorithm is that it is difficult to keep devising new algorithms that will allow reversible scrambling of information, and it is diffi-cult to quickly explain a newly devised algorithm to the person with whom you’d like to start com-municating securely. With a good cryptographic scheme it is perfectly OK to have everyone, including the bad guys (and the cryptanalysts) know the algorithm because knowledge of the algo-rithm without the key does not help unmangle the information.

The concept of a key is analogous to the combination for a combination lock. Although the concept of a combination lock is well known (you dial in the secret numbers in the correct

sequence and the lock opens), you can’t open a combination lock easily without knowing the combination.

MODERN CRYPTOGRAPHY
 
Modern cryptography is the cornerstone of computer and communications security. Its foundation is based on various concepts of mathematics such as number theory, computational-complexity theory, and probability theory.

Characteristics of Modern Cryptography


There are three major characteristics that separate modern cryptography from the classical approach.

Classic Cryptography	Modern Cryptography	
		
It manipulates traditional characters,	It operates on binary bit sequences.	
i.e., letters and digits directly.		
		
	It   relies   on   publicly   known	
It is mainly based on ‘security through	mathematical algorithms  for coding	
obscurity’. The techniques employed for	the information. Secrecy is obtained	
coding were kept secret and only the	through a secrete key which is used	
parties  involved  in  communication	as the seed for the algorithms. The	
knew about them.	computational difficulty of algorithms,	
	absence of secret key, etc., make it	
	impossible for an attacker to obtain	
	the original information even if he	
	knows the algorithm used for coding.	
		
It requires the entire cryptosystem for	Modern cryptography requires parties	
communicating confidentially.	interested in secure communication	
	to possess the secret key only.	
		


Context of Cryptography


Cryptology, the study of cryptosystems, can be subdivided into two branches:

•	Cryptography

•	Cryptanalysis

 

What is Cryptography?

Cryptography is the art and science of making a cryptosystem that is capable of providing information security.

Cryptography deals with the actual securing of digital data. It refers to the design of mechanisms based on mathematical algorithms that provide fundamental information security services. You can think of cryptography as the establishment of a large toolkit containing different techniques in security applications.

What is Cryptanalysis?

The art and science of breaking the cipher text is known as cryptanalysis.

Cryptanalysis is the sister branch of cryptography and they both co-exist. The cryptographic process results in the cipher text for transmission or storage. It involves the study of cryptographic mechanism with the intention to break them. Cryptanalysis is also used during the design of the new cryptographic techniques to test their security strengths.

Note: Cryptography concerns with the design of cryptosystems, while cryptanalysis studies the breaking of cryptosystems.

Security Services of Cryptography


The primary objective of using cryptography is to provide the following four fundamental information security services. Let us now see the possible goals intended to be fulfilled by cryptography.

Confidentiality

Confidentiality is the fundamental security service provided by cryptography. It is a security service that keeps the information from an unauthorized person. It is sometimes referred to as privacy or secrecy.



Confidentiality can be achieved through numerous means starting from physical securing to the use of mathematical algorithms for data encryption.

Data Integrity

It is security service that deals with identifying any alteration to the data. The data may get modified by an unauthorized entity intentionally or accidently. Integrity service confirms that whether data is intact or not since it was last created, transmitted, or stored by an authorized user.

Data integrity cannot prevent the alteration of data, but provides a means for detecting whether data has been manipulated in an unauthorized manner.

Authentication

Authentication provides the identification of the originator. It confirms to the receiver that the data received has been sent only by an identified and verified sender.

Authentication service has two variants:
 
1.	Message authentication identifies the originator of the message without any regard router or system that has sent the message.

2.	Entity authentication is assurance that data has been received from a specific entity, say a particular website.

Apart from the originator, authentication may also provide assurance about other parameters related to data such as the date and time of creation/transmission.

Non-repudiation

It is a security service that ensures that an entity cannot refuse the ownership of a previous commitment or an action. It is an assurance that the original creator of the data cannot deny the creation or transmission of the said data to a recipient or third party.

Non-repudiation is a property that is most desirable in situations where there are chances of a dispute over the exchange of data. For example, once an order is placed electronically, a purchaser cannot deny the purchase order, if non-repudiation service was enabled in this transaction.

Cryptography Primitives


Cryptography primitives are nothing but the tools and techniques in Cryptography that can be selectively used to provide a set of desired security services:

 Encryption

 Hash functions

 Message Authentication codes (MAC)

 Digital Signatures

The following table shows the primitives that can achieve a particular security service on their own.

Primitives	Encryption		Hash		MAC		Digital	
Service			Function				Signature	
								
								
Confidentiality	Yes		No		No		No	
								
Integrity	No		Sometimes		Yes		Yes	
								
Authentication	No		No		Yes		Yes	
								
Non Reputation	No		No		Sometimes		Yes	
								


Note: Cryptographic primitives are intricately related and they are often combined to achieve a set of desired security services from a cryptosystem.


CRYPTOSYSTEM

A cryptosystem is an implementation of cryptographic techniques and their accompanying infrastructure to provide information security services. A cryptosystem is also referred to as a cipher system.
 
Components of a Cryptosystem


The various components of a basic cryptosystem are as follows:

Plaintext.  It is the data to be protected during transmission.

Encryption Algorithm. It is a mathematical process that produces a ciphertext for any given plaintext and encryption key. It is a cryptographic algorithm that takes plaintext and an encryption key as input and produces a ciphertext.

Ciphertext. It is the scrambled version of the plaintext produced by the encryption algorithm using a specific the encryption key. The ciphertext is not guarded. It flows on public channel. It can be intercepted or compromised by anyone who has access to the communication channel.

Decryption Algorithm, It is a mathematical process, that produces a unique plaintext for any given cipher text and decryption key. It is a cryptographic algorithm that takes a cipher text and a decryption key as input, and outputs a plaintext. The decryption algorithm essentially reverses the encryption algorithm and is thus closely related to it.

Encryption Key. It is a value that is known to the sender. The sender inputs the encryption key into the encryption algorithm along with the plaintext in order to compute the ciphertext. Decryption Key. It is a value that is known to the receiver. The decryption key is related to the encryption key, but is not always identical to it. The receiver inputs the decryption key into the decryption algorithm along with the cipher text in order to compute the plaintext.

For a given cryptosystem, a collection of all possible decryption keys is called a key space. An interceptor (an attacker) is an unauthorized entity who attempts to determine the plaintext. He can see the cipher text and may know the decryption algorithm. He, however, must never know the decryption key.

Types of Cryptosystems


Fundamentally, there are two types of cryptosystems based on the manner in which encryption-decryption is carried out in the system:

 Symmetric Key Encryption

 Asymmetric Key Encryption

The main difference between these cryptosystems is the relationship between the encryption and the decryption key. Logically, in any cryptosystem, both the keys are closely associated. It is practically impossible to decrypt the cipher text with the key that is unrelated to the encryption key.

Symmetric Key Encryption

The encryption process where same keys are used for encrypting and decrypting the information is known as Symmetric Key Encryption. The study of symmetric cryptosystems is referred to as symmetric cryptography. Symmetric cryptosystems are also sometimes referred to as secret key cryptosystems.

The	study	of	symmetric	cryptosystems	is	referred	to	as	symmetric	cryptography.
Symmetric cryptosystems are also sometimes referred to as secret key cryptosystems.

In symmetric-key cryptography, the same key is used by both parties. The sender uses this key and an encryption algorithm to encrypt data; the receiver uses the same key and the corresponding decryption algorithm to decrypt the data.
 





Symmetric-key Cryptography






A few well-known examples of symmetric key encryption methods are: Digital Encryption Standard (DES), Triple-DES (3DES), IDEA, and BLOWFISH.






Prior to 1970, all cryptosystems employed symmetric key encryption. Even today, its relevance is very high and it is being used extensively in many cryptosystems. It is very unlikely that this encryption will fade away, as it has certain advantages over asymmetric key encryption.

The salient features of cryptosystem based on symmetric key encryption are:

 Persons using symmetric key encryption must share a common key prior to exchange of information.

 Keys are recommended to be changed regularly to prevent any attack on the system.

 A robust mechanism needs to exist to exchange the key between the communicating parties. As keys are required to be changed regularly, this mechanism becomes expensive and cumbersome.
 
 In a group of n people, to enable two-party communication between any two persons, the number of keys required for group is n × (n – 1)/2.

 Length of Key (number of bits) in this encryption is smaller and hence, process of encryption-decryption is faster than asymmetric key encryption.

 Processing power of computer system required to run symmetric algorithm is less.



Challenge of Symmetric Key Cryptosystem

There are two restrictive challenges of employing symmetric key cryptography.

 Key establishment – Before any communication, both the sender and the receiver need to agree on a secret symmetric key. It requires a secure key establishment mechanism in place.


 Trust Issue – Since the sender and the receiver use the same symmetric key, there is an implicit requirement that the sender and the receiver ‘trust’ each other. For example, it may happen that the receiver has lost the key to an attacker and the sender is not informed.

These two challenges are highly restraining for modern day communication. Today, people need to exchange information with non-familiar and non-trusted parties. For example, a communication between online seller and customer. These limitations of symmetric key encryption gave rise to asymmetric key encryption schemes.

Asymmetric Key Encryption

In asymmetric or public-key cryptography, there are two keys: a private key and a public key. The private key is kept by the receiver. The public key is announced to the public.The encryption process where different keys are used for encrypting and decrypting the information is known as Asymmetric Key Encryption. Though the keys are different, they are mathematically related and hence, retrieving the plaintext by decrypting ciphertext is feasible. The process is depicted in the following illustration:

 







Asymmetric Key Encryption was invented in the 20th century to come over the necessity of pre-shared secret key between communicating persons. The salient features of this encryption scheme are as follows:


 Every user in this system needs to have a pair of dissimilar keys, private key and public key. These keys are mathematically related – when one key is used for encryption, the other can decrypt the ciphertext back to the original plaintext.

 It requires to put the public key in public repository and the private key as a well-guarded secret. Hence, this scheme of encryption is also called
Public Key Encryption.

 Though public and private keys of the user are related, it is computationally not feasible to find one from another. This is a strength of this scheme.

 When Host1 needs to send data to Host2, he obtains the public key of Host2 from repository, encrypts the data, and transmits.

 Host2 uses his private key to extract the plaintext.

 Length of Keys (number of bits) in this encryption is large and hence, the process of encryption-decryption is slower than symmetric key encryption.

 Processing power of computer system required to run asymmetric algorithm is higher.

Symmetric cryptosystems are a natural concept. In contrast, public-key cryptosystems are quite difficult to comprehend.

You may think, how can the encryption key and the decryption key are ‘related’, and yet it is impossible to determine the decryption key from the encryption key?

The answer lies in the mathematical concepts. It is possible to design a cryptosystem whose keys have this property. The concept of public-key cryptography is relatively new. There are fewer public-key algorithms known than symmetric algorithms.

Challenge of Public Key Cryptosystem

Public-key cryptosystems have one significant challenge: the user needs to trust that the public key that he is using in communications with a person really is the public key of that person and has not been spoofed by a malicious third party.

This is usually accomplished through a Public Key Infrastructure (PKI) consisting a trusted third party. The third party securely manages and attests to the authenticity of public keys. When the third party is requested to provide the public key for any communicating person X, they are trusted to provide the correct public key.

The third party satisfies itself about user identity by the process of attestation, notarization, or some other process - that X is the one and only, or globally unique, X. The most common method of making the verified public keys available is to embed them in a certificate which is
 
digitally signed by the trusted third party.


Relation between Encryption Schemes


A summary of basic key properties of two types of cryptosystems is given below:

	Symmetric		Public Key Cryptosystems	
	Cryptosystems			
				
Relation between	Same		Different, but mathematically	
Keys			related	
				
Encryption Key	Symmetric		Public	
				
Decryption Key	Symmetric		Private	
				


Due to the advantages and disadvantage of both the systems, symmetric key and public-key cryptosystems are often used together in the practical information security systems.




In cryptography, the following three assumptions are made about the security environment and attacker’s capabilities.

Details of the Encryption Scheme

The design of a cryptosystem is based on the following two cryptography algorithms:

 Public Algorithms: With this option, all the details of the algorithm are in the public domain, known to everyone.

 Proprietary algorithms: The details of the algorithm are only known by the system designers and users.

In case of proprietary algorithms, security is ensured through obscurity. Private algorithms may not be the strongest algorithms as they are developed in-house and may not be extensively investigated for weakness.

Secondly, they allow communication among closed group only. Hence they are not suitable for modern communication where people communicate with large number of known or unknown entities. Also, according to Kerckhoff’s principle, the algorithm is preferred to be public with strength of encryption lying in the key.

Thus, the first assumption about security environment is that the encryption algorithm is known to the attacker.

Availability of Ciphertext

We know that once the plaintext is encrypted into ciphertext, it is put on unsecure public channel (say email) for transmission. Thus, the attacker can obviously assume that it has access to the ciphertext generated by the cryptosystem.

Availability of Plaintext and Ciphertext

This assumption is not as obvious as other. However, there may be situations where an attacker can have access to plaintext and corresponding ciphertext. Some such possible circumstances are:
 
 The attacker influences the sender to convert plaintext of his choice and obtains the ciphertext.

 The receiver may divulge the plaintext to the attacker inadvertently. The attacker has access to corresponding ciphertext gathered from open channel.

 In a public-key cryptosystem, the encryption key is in open domain and is known to any potential attacker. Using this key, he can generate pairs of corresponding plaintexts and ciphertexts.




Earlier Cryptographic Systems


Before proceeding further, you need to know some facts about historical cryptosystems:


All of these systems are based on symmetric key encryption scheme.


The only security service these systems provide is confidentiality of information.


Unlike modern systems which are digital and treat data as binary numbers, the earlier systems worked on alphabets as basic element.

These earlier cryptographic systems are also referred to as Ciphers. In general, a cipher is simply just a set of steps (an algorithm) for performing both an encryption, and the corresponding decryption.

Caesar Cipher


It is a mono-alphabetic cipher wherein each letter of the plaintext is substituted by another letter to form the ciphertext. It is a simplest form of substitution cipher scheme.

This cryptosystem is generally referred to as the Shift Cipher. The concept is to replace each alphabet by another alphabet which is ‘shifted’ by some fixed number between 0 and 25.

For this type of scheme, both sender and receiver agree on a ‘secret shift number’ for shifting the alphabet. This number which is between 0 and 25 becomes the key of encryption.

The name ‘Caesar Cipher’ is occasionally used to describe the Shift Cipher when the ‘shift of three’ is used.


Process of Shift Cipher

 In order to encrypt a plaintext letter, the sender positions the sliding ruler underneath the first set of plaintext letters and slides it to LEFT by the number of positions of the secret shift.

 The plaintext letter is then encrypted to the ciphertext letter on the sliding ruler underneath. The result of this process is depicted in the following illustration for an agreed shift of three positions. In this case, the plaintext

‘tutorial’ is encrypted to the ciphertext ‘WXWRULDO’. Here is the ciphertext alphabet for a Shift of 3:

 



 On receiving the ciphertext, the receiver who also knows the secret shift, positions his sliding ruler underneath the ciphertext alphabet and slides it to RIGHT by the agreed shift number, 3 in this case.

 He then replaces the ciphertext letter by the plaintext letter on the sliding ruler underneath. Hence the ciphertext ‘WXWRULDO’ is decrypted to ‘tutorial’. To decrypt a message encoded with a Shift of 3, generate the plaintext alphabet using a shift of ‘-3’ as shown below:










MODERN SYMMETRIC KEY ENCRYPTION




Digital data is represented in strings of binary digits (bits) unlike alphabets. Modern cryptosystems need to process this binary strings to convert in to another binary string. Based on how these binary strings are processed, a symmetric encryption schemes can be classified in to:

Block Ciphers


In this scheme, the plain binary text is processed in blocks (groups) of bits at a time; i.e. a block of plaintext bits is selected, a series of operations is performed on this block to generate a block of ciphertext bits. The number of bits in a block is fixed. For example, the schemes DES and AES have block sizes of 64 and 128, respectively.

Stream Ciphers


In this scheme, the plaintext is processed one bit at a time i.e. one bit of plaintext is taken, and a series of operations is performed on it to generate one bit of cipher text. Technically, stream ciphers are block ciphers with a block size of one bit.




The basic scheme of a block cipher is depicted as follows:
 
















A block cipher takes a block of plaintext bits and generates a block of ciphertext bits, generally of same size. The size of block is fixed in the given scheme. The choice of block size does not directly affect to the strength of encryption scheme. The strength of cipher depends up on the key length.

Block Size


Though any size of block is acceptable, following aspects are borne in mind while selecting a size of a block.

 Avoid very small block size: Say a block size is m bits. Then the possible plaintext bits combinations are then 2m. If the attacker discovers the plain text blocks corresponding to some previously sent ciphertext blocks, then the attacker can launch a type of ‘dictionary attack’ by building up a dictionary of plaintext/ciphertext pairs sent using that encryption key. A larger block size makes attack harder as the dictionary needs to be larger.


 Do not have very large block size: With very large block size, the cipher becomes inefficient to operate. Such plaintexts will need to be padded before being encrypted.


 Multiples of 8 bit: A preferred block size is a multiple of 8 as it is easy for implementation as most computer processor handle data in multiple of 8 bits.


Padding in Block Cipher


Block ciphers process blocks of fixed sizes (say 64 bits). The length of plaintexts is mostly not a multiple of the block size. For example, a 150-bit plaintext provides two blocks of 64 bits each with third block of balance 22 bits. The last block of bits needs to be padded up with redundant information so that the length of the final block equal to block size of the scheme. In our example, the remaining 22 bits need to

have additional 42 redundant bits added to provide a complete block. The process of adding bits to the last block is referred to as padding.

Too much padding makes the system inefficient. Also, padding may render the system insecure at times, if the padding is done with same bits always.

Block Cipher Schemes


There is a vast number of block ciphers schemes that are in use. Many of them are publically known. Most popular and prominent block ciphers are listed below.
 
 Digital Encryption Standard (DES): The popular block cipher of the

1990s. It is now considered as a ‘broken’ block cipher, due primarily to its small key size.

 Triple DES: It is a variant scheme based on repeated DES applications. It is still a respected block ciphers but inefficient compared to the new faster block ciphers available.

 Advanced Encryption Standard (AES): It is a relatively new block cipher based on the encryption algorithm Rijndael that won the AES design competition.

 IDEA: It is a sufficiently strong block cipher with a block size of 64 and a key size of 128 bits. A number of applications use IDEA encryption, including early versions of Pretty Good Privacy (PGP) protocol. The use of IDEA scheme has a restricted adoption due to patent issues.

 Twofish: This scheme of block cipher uses block size of 128 bits and a key of variable length. It was one of the AES finalists. It is based on the earlier block cipher Blowfish with a block size of 64 bits.

 Serpent: A block cipher with a block size of 128 bits and key lengths of 128, 192, or 256 bits, which was also an AES competition finalist. It is a slower but has more secure design than other block cipher.


An important distinction in symmetric cryptographic algorithms is between stream and block ciphers.

Stream cipher: Stream ciphers convert one symbol of plaintext directly into a symbol of ciphertext.

Advantages:
Speed of transformation: algorithms are linear in time and constant in space.

Low error propogation: an error in encrypting one symbol likely will not affect subsequent symbols.

Disadvantages:

Low diffusion: all information of a plaintext symbol is contained in a single ciphertext symbol.

Susceptibility to insertions/ modifications: an active interceptor who breaks the algorithm might insert spurious text that looks authentic.

Block ciphers: It encrypt a group of plaintext symbols as one block.

Advantages:

High diffusion: information from one plaintext symbol is diffused into several ciphertext symbols.

Immunity to tampering: difficult to insert symbols without detection.

Disadvantages:

Slowness of encryption: an entire block must be accumulated before encryption / decryption can begin.

Error propagation: An error in one symbol may corrupt the entire block.

Simple substitution is an example of a stream cipher. Columnar transposition is a block cipher.


The Data Encryption Standard (DES)
 
The Data Encryption Standard (DES), a system developed for the U.S. government, was intended for use by the general public. It has been officially accepted as a cryptographic standard both in the United States and abroad.

The DES algorithm is a careful and complex combination of two fundamental building blocks of encryption: substitution and transposition. The algorithm derives its strength from repeated application of these two techniques, one on top of the other, for a total of 16 cycles. The sheer complexity of tracing a single bit through 16 iterations of substitutions and transpositions has so far stopped researchers in the public from identifying more than a handful of general properties of the algorithm. The algorithm begins by encrypting the plaintext as blocks of 64 bits. The key is 64 bits long, but in fact it can be any 56-bit number. (The extra 8 bits are often used as check digits and do not affect encryption in normal implementations.) The user can change the key at will any time there is uncertainty about the Final permutation.

The Data Encryption Standard (DES) is a symmetric-key block cipher published by the National Institute of Standards and Technology (NIST).

DES is an implementation of a Feistel Cipher. It uses 16 round Feistel structure. The block size is 64-bit. Though, key length is 64-bit, DES has an effective key length of 56 bits, since 8 of the 64 bits of the key are not used by the encryption algorithm (function as check bits only)

 
Since DES is based on the Feistel Cipher, all that is required to specify DES is:

 Round function
 Key schedule
 Any additional processing – Initial and final permutation

Initial and Final Permutation


The initial and final permutations are straight Permutation boxes (P-boxes) that are inverses of each other. They have no cryptography significance in DES. The initial and final permutations are shown as follows:
































Round Function


The heart of this cipher is the DES function, f. The DES function applies a 48-bit key to the rightmost 32 bits to produce a 32-bit output.

 
 Expansion Permutation Box – Since right input is 32-bit and round key is a 48-bit, we first need to expand right input to 48 bits. Permutation logic is graphically depicted in the following illustration:
















XOR (Whitener). After the expansion permutation, DES does XOR operation on the expanded right section and the round key. The round key is used only in this operation. Substitution Boxes. The S-boxes carry out the real mixing (confusion). DES uses 8 S-boxes, each with a 6-bit input and a 4-bit output. Refer the following illustration:














Straight Permutation – The 32 bit output of S-boxes is then subjected to the straight permutation with rule shown in the following illustration:

 
Key Generation


The round-key generator creates sixteen 48-bit keys out of a 56-bit cipher key. The process of key generation is depicted in the following illustration






The logic for Parity drop, shifting, and Compression P-box is given in the DES description.

DES Analysis


The DES satisfies both the desired properties of block cipher. These two properties make cipher very strong.

 Avalanche effect: A small change in plaintext results in the very grate change in the ciphertext.

 Completeness: Each bit of ciphertext depends on many bits of plaintext.

During the last few years, cryptanalysis have found some weaknesses in DES when key selected are weak keys. These keys shall be avoided.

DES has proved to be a very well designed block cipher. There have been no significant cryptanalytic attacks on DES other than exhaustive key search.
 
Public Key Cryptography

 

Unlike symmetric key cryptography, we do not find historical use of public-key cryptography.
It is a relatively new concept.

Symmetric cryptography was well suited for organizations such as governments, military, and big financial corporations were involved in the classified communication.

With the spread of more unsecure computer networks in last few decades, a genuine need was felt to use cryptography at larger scale. The symmetric key was found to be non-practical due to challenges it faced for key management. This gave rise to the public key cryptosystems.

The process of encryption and decryption is depicted in the following illustration:






The most important properties of public key encryption scheme are:

 Different keys are used for encryption and decryption. This is a property which set this scheme different than symmetric encryption scheme.

 Each receiver possesses a unique decryption key, generally referred to as his private key.
 Receiver needs to publish an encryption key, referred to as his public key.

 Some assurance of the authenticity of a public key is needed in this scheme to avoid spoofing by adversary as the receiver. Generally, this type of cryptosystem involves trusted third party which certifies that a particular public key belongs to a specific person or entity only.

 Encryption algorithm is complex enough to prohibit attacker from deducing the plaintext from the ciphertext and the encryption (public) key.

 Though private and public keys are related mathematically, it is not be feasible to calculate the private key from the public key. In fact, intelligent part of any public-key cryptosystem is in designing a relationship between two keys.


Public-key cryptography is a radical departure from all that has gone before. Right up to modern times all cryptographic systems have been based on the
 
elementary tools of substitution and permutation. However, public-key algorithms are based on mathematical functions and are asymmetric in nature, involving the use of two keys, as opposed to conventional single key encryption. Several misconceptions are held about p-k:

1.	That p-k encryption is more secure from cryptanalysis than conventional encryp-tion. In fact the security of any system depends on key length and the computa-tional work involved in breaking the cipher.

2.	That p-k encryption has superseded single key encryption. This is unlikely due to the increased processing power required.

3.	That key management is trivial with public key cryptography, this is not correct.

Principles of Public-Key Cryptosystems

The concept of P-K evolved from an attempt to solve two problems, key distribution and the development of digital signatures. In 1976 Whitfield Diffie and Martin Hell- man achieved great success in developing the conceptual framework. For conventional encryption the same key is used for encryption and decryption. This is not a necessary condition. Instead it is possible to develop a cryptographic system that relies on one key for encryption and a different but related key for decryption. Furthermore these algorithms have the following important characteristic:

It is computationally infeasible to determine the decryption key given only knowledge of the algorithm and the encryption key.

In addition, some algorithms such as RSA, also exhibits the following characteristics:
Either of the two related keys can be used for encryption, with the	other used for

decryption.




The steps are:

1.	Each system generates a pair of keys.

2.	Each system publishes its encryption key (public key) keeping its companion key private.

3.	If A wishes to send a message to B it encrypts the message using B’s public key.
 
4.	When B receives the message, it decrypts the message using its private key. No one else can decrypt the message because only B knows its private key.


There are three types of Public Key Encryption schemes.

RSA Cryptosystem


This cryptosystem is one the initial system. It remains most employed cryptosystem even today. The system was invented by three scholars Ron Rivest, Adi Shamir, and Len Adleman and hence, it is termed as RSA cryptosystem.

We will see two aspects of the RSA cryptosystem, firstly generation of key pair and secondly encryption-decryption algorithms.

Generation of RSA Key Pair

Each person or a party who desires to participate in communication using encryption needs to generate a pair of keys, namely public key and private key. The process followed in the generation of keys is described below:

 Generate the RSA modulus (n)

o Select two large primes, p and q.

o	Calculate n=p*q. For strong unbreakable encryption, let n be a large number, typically a minimum of 512 bits.

 Find Derived Number (e)

 Number e must be greater than 1 and less than (p − 1)(q − 1).

 There must be no common factor for e and (p − 1)(q − 1) except for 1.
In other words two numbers e and (p – 1)(q – 1) are coprime.




Form the public key

o The pair of numbers (n, e) form the RSA public key and is made public.

o	Interestingly, though n is part of the public key, difficulty in factorizing a large prime number ensures that attacker cannot find in finite time the two primes (p & q) used to obtain n. This is strength of RSA.

 Generate the private key

o	Private Key d is calculated from p, q, and e. For given n and e, there is unique number d.

o	Number d is the inverse of e modulo (p − 1)(q – 1). This means that d is the number less than (p − 1)(q − 1) such that when multiplied by e, it is equal to 1 modulo (p − 1)(q − 1).

o This relationship is written mathematically as follows:

 
ed = 1 mod (p − 1)(q − 1)

The Extended Euclidean Algorithm takes p, q, and e as input and gives d as output.

Example

An example of generating RSA Key pair is given below. (For ease of understanding, the primes p & q taken here are small values. Practically, these values are very high).

 Let two primes be p = 7 and q = 13. Thus, modulus n = pq = 7 x 13 = 91.

 Select e = 5, which is a valid choice since there is no number that is common factor of 5 and (p − 1)(q − 1) = 6 × 12 = 72, except for 1.

 The pair of numbers (n, e) = (91, 5) forms the public key and can be made available to anyone whom we wish to be able to send us encrypted messages.

 Input p = 7, q = 13, and e = 5 to the Extended Euclidean Algorithm. The output will be d = 29.

 Check that the d calculated is correct by computing:


de = 29 × 5 = 145 = 1 mod 72


 Hence, public key is (91, 5) and private keys is (91, 29).


Encryption and Decryption

Once the key pair has been generated, the process of encryption and decryption are relatively straightforward and computationally easy.

Interestingly, RSA does not directly operate on strings of bits as in case of symmetric key encryption. It operates on numbers modulo n. Hence, it is necessary to represent the plaintext as a series of numbers less than n.

RSA Encryption

 Suppose the sender wish to send some text message to someone whose public key is (n, e).

 The sender then represents the plaintext as a series of numbers less than n.

 To encrypt the first plaintext P, which is a number modulo n. The encryption process is simple mathematical step as:


C = Pe mod n

 In other words, the ciphertext C is equal to the plaintext P multiplied by itself e times and then reduced modulo n. This means that C is also a number less than n.

 Returning to our Key Generation example with plaintext P = 10, we get ciphertext C:


C = 105 mod 91


RSA Decryption

 The decryption process for RSA is also very straightforward. Suppose that the receiver
 
of public-key pair (n, e) has received a ciphertext C.

 Receiver raises C to the power of his private key d. The result modulo n will be the plaintext P.


Plaintext = Cd mod n

 Returning again to our numerical example, the ciphertext C = 82 would get decrypted to number 10 using private key 29:


Plaintext = 8229 mod 91 = 10



RSA Analysis

The security of RSA depends on the strengths of two separate functions. The RSA cryptosystem is most popular public-key cryptosystem strength of which is based on the practical difficulty of factoring the very large numbers.

 Encryption Function: It is considered as a one-way function of converting plaintext into ciphertext and it can be reversed only with the knowledge of private key d.

 Key Generation: The difficulty of determining a private key from an RSA public key is equivalent to factoring the modulus n. An attacker thus cannot use knowledge of an RSA public key to determine an RSA private key unless he can factor n. It is also a one way function, going from p & q values to modulus n is easy but reverse is not possible.

If either of these two functions are proved non one-way, then RSA will be broken. In fact, if a technique for factoring efficiently is developed then RSA will no longer be safe.

The strength of RSA encryption drastically goes down against attacks if the number p and q are not large primes and/ or chosen public key e is a small number.


TYPES OF CRYPTOGRAPHIC FUNCTIONS


Hash functions


Hash functions are extremely useful and appear in almost all information security applications.

A hash function is a mathematical function that converts a numerical input value into another compressed numerical value. The input to the hash function is of arbitrary length but output is always of fixed length.

Values returned by a hash function are called message digest or simply hash values. The following picture illustrated hash function:

 






Features of Hash Functions


The typical features of hash functions are:

Fixed Length Output (Hash Value)

Hash function coverts data of arbitrary length to a fixed length. This process is often referred to as hashing the data.

In general, the hash is much smaller than the input data, hence hash functions are sometimes called compression functions.

Since a hash is a smaller representation of a larger data, it is also referred to as a digest.

o	Hash function with n bit output is referred to as an n-bit hash function. Popular hash functions generate values between 160 and 512 bits.


 Efficiency of Operation

o	Generally for any hash function h with input x, computation of h(x) is a fast operation.

o	Computationally hash functions are much faster than a symmetric encryption.

Properties of Hash Functions


In order to be an effective cryptographic tool, the hash function is desired to possess following properties:

 Pre-Image Resistance

o This property means that it should be computationally hard to reverse a hash function.

o In other words, if a hash function h produced a hash value z, then it should be a difficult process to find any input value x that hashes to z.

o This property protects against an attacker who only has a hash value and is trying to find the input.

 Second Pre-Image Resistance

o This property means given an input and its hash, it should be hard to find a different input with the same hash.

o In other words, if a hash function h for an input x produces hash value h(x), then it should be difficult to find any other input value y such that h(y) = h(x).

o This property of hash function protects against an attacker who has an input value and its hash, and wants to substitute different value as legitimate value in place of original input value.
 
 Collision Resistance

o This property means it should be hard to find two different inputs of any length that result in the same hash. This property is also referred to as collision free hash function.

o In other words, for a hash function h, it is hard to find any two different inputs x and y such that h(x) = h(y).

o	Since, hash function is compressing function with fixed hash length, it is impossible for a hash function not to have collisions. This property of collision free only confirms that these collisions should be hard to find.

o	This property makes it very difficult for an attacker to find two input values with the same hash.

o	Also, if a hash function is collision-resistant then it is second pre-image resistant.

Design of Hashing Algorithms


At the heart of a hashing is a mathematical function that operates on two fixed-size blocks of data to create a hash code. This hash function forms the part of the hashing algorithm.

The size of each data block varies depending on the algorithm. Typically the block sizes are from 128 bits to 512 bits. The following illustration demonstrates hash function:















Hashing algorithm involves rounds of above hash function like a block cipher. Each round takes an input of a fixed size, typically a combination of the most recent message block and the output of the last round.

This process is repeated for as many rounds as are required to hash the entire message.
Schematic of hashing algorithm is depicted in the following illustration:













Since, the hash value of first message block becomes an input to the second hash operation, output of which alters the result of the third operation, and so on. This effect, known as an avalanche effect of hashing.

Avalanche effect results in substantially different hash values for two messages that differ by even a single bit of data.
 
Understand the difference between hash function and algorithm correctly. The hash function generates a hash code by operating on two blocks of fixed-length binary data.

Hashing algorithm is a process for using the hash function, specifying how the message will be broken up and how the results from previous message blocks are chained together.

Popular Hash Functions


Let us briefly see some popular hash functions:

Message Digest (MD)

MD5 was most popular and widely used hash function for quite some years.

 The MD family comprises of hash functions MD2, MD4, MD5 and MD6. It was adopted as Internet Standard RFC 1321. It is a 128-bit hash function.

 MD5 digests have been widely used in the software world to provide assurance about integrity of transferred file. For example, file servers often provide a pre-computed MD5 checksum for the files, so that a user can compare the checksum of the downloaded file to it.

 In 2004, collisions were found in MD5. An analytical attack was reported to be successful only in an hour by using computer cluster. This collision attack resulted in compromised MD5 and hence it is no longer recommended for use.

MD5

The MD5 function is a cryptographic algorithm that takes an input of arbitrary length and produces a message digest that is 128 bits long. The digest is sometimes also called the "hash" or "fingerprint" of the input. MD5 is used in many situations where a potentially long message needs to be processed and/or compared quickly. The most common application is the creation and verification of digital signatures.

MD5 was designed by well-known cryptographer Ronald Rivest in 1991. In 2004, some serious flaws were found in MD5. The complete implications of these flaws has yet to be determined.

How MD5 works

Preparing the input

The MD5 algorithm first divides the input in blocks of 512 bits each. 64 Bits are inserted at the end of the last block. These 64 bits are used to record the length of the original input. If the last block is less than 512 bits, some extra bits are 'padded' to the end.

Next, each block is divided into 16 words of 32 bits each. These are denoted as M0 ...
M15.

MD5 helper functions

The buffer

MD5 uses a buffer that is made up of four words that are each 32 bits long. These words are called A, B, C and D. They are initialized as

word A: 01 23 45 67

word B: 89 ab cd ef

word C: fe dc ba 98

word D: 76 54 32 10
 
The table

MD5 further uses a table K that has 64 elements. Element number i is indicated as Ki. The table is computed beforehand to speed up the computations. The elements are computed using the mathematical sin function:

Ki = abs(sin(i + 1)) * 232

Four auxiliary functions

In addition MD5 uses four auxiliary functions that each take as input three 32-bit words and produce as output one 32-bit word. They apply the logical operators and, or, not and xor to the input bits.

F(X,Y,Z)	=	(X	and	Y)	or
(not(X) and Z)

G(X,Y,Z)  = (X and Z) or (Y
and not(Z))

H(X,Y,Z) = X xor Y xor Z

I(X,Y,Z) = Y xor (X or not(Z))

Processing the blocks

The contents of the four buffers (A, B, C and D) are now mixed with the words of the input, using the four auxiliary functions (F, G, H and I). There are four rounds, each involves 16 basic operations. One operation is illustrated in the figure below.





















The figure shows how the auxiliary function F is applied to the four buffers (A, B, C and D), using message word Mi and constant Ki. The item "<<<s" denotes a binary left shift by s bits.

The output

After all rounds have been performed, the buffers A, B, C and D contain the MD5 digest of the original input.



Secure Hash Function (SHA)

Family of SHA comprise of four SHA algorithms; SHA-0, SHA-1, SHA-2, and SHA-
3.	Though from same family, there are structurally different.

 The original version is SHA-0, a 160-bit hash function, was published by the National Institute of Standards and Technology (NIST) in 1993. It had few weaknesses and did not become very popular. Later in 1995, SHA-1 was designed to correct alleged
 
weaknesses of SHA-0.

 SHA-1 is the most widely used of the existing SHA hash functions. It is employed in several widely used applications and protocols including Secure Socket Layer (SSL) security.
 
Digital signatures


Digital signatures are the public-key primitives of message authentication. In the physical world, it is common to use handwritten signatures on handwritten or typed messages. They are used to bind signatory to the message.

Similarly, a digital signature is a technique that binds a person/entity to the digital data. This binding can be independently verified by receiver as well as any third party.

Digital signature is a cryptographic value that is calculated from the data and a secret key known only by the signer.

In real world, the receiver of message needs assurance that the message belongs to the sender and he should not be able to repudiate the origination of that message. This requirement is very crucial in business applications, since likelihood of a dispute over exchanged data is very high.

Model of Digital Signature


As mentioned earlier, the digital signature scheme is based on public key cryptography. The model of digital signature scheme is depicted in the following illustration:

















The following points explain the entire process in detail:

 Each person adopting this scheme has a public-private key pair.

 Generally, the key pairs used for encryption/decryption and signing/verifying are different. The private key used for signing is referred to as the signature key and the public key as the verification key.
 Signer feeds data to the hash function and generates hash of data.


 Hash value and signature key are then fed to the signature algorithm which produces the digital signature on given hash. Signature is appended to the data and then both are sent to the verifier.

 Verifier feeds the digital signature and the verification key into the verification algorithm.
 
The verification algorithm gives some value as output.

 Verifier also runs same hash function on received data to generate hash value.

 For verification, this hash value and output of verification algorithm are compared. Based on the comparison result, verifier decides whether the digital signature is valid.

 Since digital signature is created by ‘private’ key of signer and no one else can have this key; the signer cannot repudiate signing the data in future.

It should be noticed that instead of signing data directly by signing algorithm, usually a hash of data is created. Since the hash of data is a unique representation of data, it is sufficient to sign the hash in place of data. The most important reason of using hash instead of data directly for signing is efficiency of the scheme.

Let us assume RSA is used as the signing algorithm. As discussed in public key encryption chapter, the encryption/signing process using RSA involves modular exponentiation.

Signing large data through modular exponentiation is computationally expensive and time consuming. The hash of the data is a relatively small digest of the data, hence signing a hash is more efficient than signing the entire data.

Importance of Digital Signature


Out of all cryptographic primitives, the digital signature using public key cryptography is considered as very important and useful tool to achieve information security.

Apart from ability to provide non-repudiation of message, the digital signature also provides message authentication and data integrity. Let us briefly see how this is achieved by the digital signature:

 Message authentication – When the verifier validates the digital signature using public key of a sender, he is assured that signature has been created only by sender who possess the corresponding secret private key and no one else.


 Data Integrity – In case an attacker has access to the data and modifies it, the digital signature verification at receiver end fails. The hash of modified data and the output provided by the verification algorithm will not match. Hence, receiver can safely deny the message assuming that data integrity has been breached.

 Non-repudiation – Since it is assumed that only the signer has the knowledge of the signature key, he can only create unique signature on a given data. Thus the receiver can present data and the digital signature to a third party as evidence if any dispute arises in the future.

By adding public-key encryption to digital signature scheme, we can create a cryptosystem that
 
can provide the four essential elements of security namely: Privacy, Authentication, Integrity, and Non-repudiation.

Encryption with Digital Signature


In many digital communications, it is desirable to exchange an encrypted messages than plaintext to achieve confidentiality. In public key encryption scheme, a public (encryption) key of sender is available in open domain, and hence anyone can spoof his identity and send any encrypted message to the receiver.

This makes it essential for users employing PKC for encryption to seek digital signatures along with encrypted data to be assured of message authentication and non-repudiation.

This can archived by combining digital signatures with encryption scheme. Let us briefly discuss how to achieve this requirement. There are two possibilities, sign-then-encrypt and encrypt-then-sign.

However, the crypto system based on sign-then-encrypt can be exploited by receiver to spoof identity of sender and sent that data to third party. Hence, this method is not preferred. The process of encrypt-then-sign is more reliable and widely adopted. This is depicted in the following illustration:














PUBLIC KEY INFRASTRUCTURE


The receiver after receiving the encrypted data and signature on it, first verifies the signature using sender’s public key. After ensuring the validity of the signature, he then retrieves the data through decryption using his private key.

The most distinct feature of Public Key Infrastructure (PKC) is that it uses a pair of keys to achieve the underlying security service. The key pair comprises of private key and public key.

Since the public keys are in open domain, they are likely to be abused. It is, thus, necessary to establish and maintain some kind of trusted infrastructure to manage these keys.

Key Management


It goes without saying that the security of any cryptosystem depends upon how securely its keys
 

are managed. Without secure procedures for the handling of cryptographic keys, the benefits of the use of strong cryptographic schemes are potentially lost.

It is observed that cryptographic schemes are rarely compromised through weaknesses in their design. However, they are often compromised through poor key management.

There are some important aspects of key management which are as follows:

 Cryptographic keys are nothing but special pieces of data. Key management refers to the secure administration of cryptographic keys.

Key management deals with entire key lifecycle as depicted in the following illustration:




 There are two specific requirements of key management for public key cryptography.

o Secrecy of private keys. Throughout the key lifecycle, secret keys must remain secret from all parties except those who are owner and are authorized to use them.

o Assurance of public keys. In public key cryptography, the public keys are in open domain and seen as public pieces of data. By default there are no assurances of whether a public key is correct, with whom it can be associated, or what it can be used for. Thus key management of public keys needs to focus much more explicitly on assurance of purpose of public keys.

The most crucial requirement of ‘assurance of public key’ can be achieved through the public-key infrastructure (PKI), a key management systems for supporting public-key cryptography.



Public Key Infrastructure (PKI)


PKI provides assurance of public key. It provides the identification of public keys and their distribution. An anatomy of PKI comprises of the following components.

 Public Key Certificate, commonly referred to as ‘digital certificate’.

 Private Key tokens.
 